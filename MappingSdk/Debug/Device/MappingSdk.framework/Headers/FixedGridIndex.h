/**************************************************
 * Copyright (c)2009 Maptext, Inc. All rights reserved.
 * www:   http://www.maptext.com
 * email: support@maptext.com
 *-------------------------------------------------
 * Workfile: $HeadURL: https://martin@mtsrv.maptext.local:8443/svn/maptext/Products/MapText/DTP/dev/src/LabelingEngine/LabelingEngine/FixedGridIndex.h $
 * 
 * Revision: $Revision: 45122 $
 *
 * Last modified on: $Date: 2013-02-20 17:18:30 -0500 (Wed, 20 Feb 2013) $, by: $Author: mfraczak $
 * 
 *************************************************/

#ifndef DTP_FIXEDGRIDINDEX_H
#define DTP_FIXEDGRIDINDEX_H

#include "LabelingEngineDefs.h"
#include "SpatialIndex.h"
#include <math.h>

#pragma warning( push )
#pragma warning( disable: 4512 )

namespace MapText
{
	namespace Dtp
	{
		/**
		* Forward declare pointer-only dependencies
		*/

		/**
		 * A single grid cell in the fixed grid spatial index
		 * @reqid 001.0064
		 */
		class LABELINGENGINE_API GridCell
		{
		public:
			/**
			 * Possible error codes generated by the class
			 * @reqid 001.0064
			 */
			enum ErrorCode
			{
				ErrorCode_AllocationError = 1,
			};

			/**
			 * Default constructor. Initializes the cell dictionary to NULL.
			 * @reqid 001.0064
			 */
			GridCell() : m_dictionary( NULL ),
				m_lastDictionaryPolyline( NULL ), m_lastIndex(-1), m_lastPolyline( NULL )
			{

			}

			/**
			 * Destructor. Dictionary is deleted.
			 * @reqid 001.0064
			 */
			~GridCell()
			{
				delete m_dictionary;
			}

			/**
			* Gets Dictionary
			* @return Dictionary
			* @reqid 001.0064
			*/
			IndexDictionaryEntry::Collection* GetDictionary() const 
			{ 
				return m_dictionary; 
			}

			/**
			 * Insert a single polyline segment into the cell dictionary. Adjacent segments are 
			 * merged into a single PolylinePart provided they are added consecutively.
			 * @param polyline the polyline to which the segment belongs
			 * @param segmentNumber number of the segment (== number of the vertex at which the segment begins)
			 * @param featureRef the feature to which the polyline belongs
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			void InsertPolylineSegment( Polyline& polyline, int segmentNumber, const Feature& featureRef, Error& errorInfo );

			/**
			 * Insert a text part into the cell dictionary.
			 * @param textPart - text part to be inserted.
			 * @param label - the label to which the text part belongs.
			 * @param error - [out] error info.
			 * @reqid 001.0064
			 */
			void InsertTextPart( TextPart* textPart, Label* label, Error& error );
			
			/**
			 * Insert a leader into the cell dictionary.
			 * @param leader - leader to be inserted.
			 * @param label - the label to which the leader belongs.
			 * @param error - [out] error info.
			 * @reqid 001.0064
			 */
			void InsertLeader( Leader* leader, Label* label, Error& error );

			/**
			 * Insert an assembly symbol component into the cell dictionary
			 * @param symbolComponent - the symbol component to be inserted.
			 * @param label - owner of the component.
			 * @param error - [out] error info.
			 * @reqid 001.0064
			 */
			void InsertSymbolComponent( SymbolComponent* symbolComponent, Label* label, Error& error );

			/**
			 * Insert an opaque polygon into the cell dictionary.
			 * @param feature - owner of the polygon.
			 * @param error - [out] error info.
			 * @reqid 001.0065
			 */
			void InsertOpaquePolygon( const Feature& feature, Error& error );

		private:
			IndexDictionaryEntry::Collection* m_dictionary;
			const Polyline* m_lastPolyline;
			PolylinePart* m_lastDictionaryPolyline;
			int m_lastIndex;

			/**
			* Initialize the dictionary to an empty collection.
			* @param errorInfo error code
			* @return 0 on success, non-zero error code otherwise
			* @reqid 001.0064
			*/
			void InitializeDictionary( Error& errorInfo );

			void InsertEntry( IndexDictionaryEntry* entry, Error& errorInfo );
		};

		/**
		 * Interface for a segment inserter - properly handles a segment insertion
		 * into a map cell for different types of obstacles.
		 * This class hierarchy was created to allow a common insertion algorithm
		 * to be executed on different types of obstacles 
		 * (@see FixedGridIndex::InsertSegment).
		 */
		class LABELINGENGINE_API ISegmentInserter
		{
		public:

			/**
			 * Insert the owned segment into a cell supplied
			 * @param cell the cell to which the segment should be inserted
			 * @param error error information
			 * @reqid 001.0064
			 */
			virtual void Insert( GridCell* cell, Error& error ) = 0;

			/**
			 * Make sure proper destructor is called by declaring it virtual.
			 * @reqid 001.0064
			 */
			virtual ~ISegmentInserter(){};
		};

		/**
		 * A segment inserter for inserting a text part.
		 */
		class LABELINGENGINE_API TextPartSegmentInserter : public ISegmentInserter
		{
		public:

			/**
			 * Constructor.
			 * @param textPart the text part which will be inserted by this object.
			 * @param label owner of the text part
			 * @return error information
			 * @reqid 001.0064
			 */
			TextPartSegmentInserter( TextPart* textPart, Label* label )
				: m_label( label ), m_textPart( textPart )
			{
			}

			/**
			 * @see ISegmentInserter::Insert
			 * @reqid 001.0064
			 */
			void Insert( GridCell* cell, Error& error )
			{
				cell->InsertTextPart( m_textPart, m_label, error );
			}

		private:
			Label* m_label;
			TextPart* m_textPart;
		};

		/**
		* A segment inserter for inserting a symbol component.
		*/
		class LABELINGENGINE_API SymbolComponentInserter : public ISegmentInserter
		{
		public:

			/**
			* Constructor.
			* @param symbolComponent the symbol component which will be inserted by this object.
			* @param label owner of the text part
			* @reqid 001.0064
			*/
			SymbolComponentInserter( SymbolComponent* symbolComponent, Label* label )
				: m_label( label ), m_symbolComponent( symbolComponent )
			{
			}

			/**
			* @see ISegmentInserter::Insert
			* @reqid 001.0064
			*/
			void Insert( GridCell* cell, Error& error )
			{
				cell->InsertSymbolComponent( m_symbolComponent, m_label, error );
			}

		private:
			Label* m_label;
			SymbolComponent* m_symbolComponent;
		};

		/**
		* A segment inserter for inserting a symbol component.
		*/
		class LABELINGENGINE_API OpaquePolygonInserter : public ISegmentInserter
		{
		public:

			/**
			* Constructor.
			* @param symbolComponent the symbol component which will be inserted by this object.
			* @param label owner of the text part
			* @reqid 001.0064
			*/
			OpaquePolygonInserter( const Feature& feature )
				: m_feature( &feature )
			{
			}

			/**
			* @see ISegmentInserter::Insert
			* @reqid 001.0064
			*/
			void Insert( GridCell* cell, Error& error )
			{
				cell->InsertOpaquePolygon( *m_feature, error );
			}

		private:
			const Feature* m_feature;
		};

		/**
		 * A segment inserter for polyline segment.
		 */
		class LABELINGENGINE_API PolylineSegmentInserter : public ISegmentInserter
		{
		public:

			/**
			 * Constructor. The segment number is preset to 0.
			 * @param polyline owner of the segment.
			 * @param feature owner of the polyline
			 * @reqid 001.0064
			 */
			PolylineSegmentInserter( Polyline& polyline, const Feature& feature )
				: m_polyline( polyline ), m_feature( feature ), m_segment(0)
			{
			}

			/**
			* @see ISegmentInserter::Insert
			* @reqid 001.0064
			*/
			void Insert( GridCell* cell, Error& error )
			{
				cell->InsertPolylineSegment( m_polyline, m_segment, m_feature, error );
			}

			/**
			 * Set the segment which should be inserted.
			 * @param segment segment number
			 * @reqid 001.0064
			 */
			void SetSegment( int segment )
			{
				m_segment = segment;
			}
            
            /**
             * Get the feature reference
             * @return The associated feature.
             * @reqid 001.0064
             */
            const Feature* GetFeatureReference()
            {
                return &m_feature;
            }
		private:
			Polyline& m_polyline;
			const Feature& m_feature;
			int m_segment;
		};

		/**
		 * A segment inserter for a leader segment.
		 */
		class LABELINGENGINE_API LeaderSegmentInserter : public ISegmentInserter
		{
		public:

			/**
			 * Constructor.
			 * @param leader the leader to be inserted
			 * @param label owner of the leader
			 * @reqid 001.0064
			 */
			LeaderSegmentInserter( Leader* leader, Label* label )
				: m_label( label ), m_leader( leader )
			{
			}

			/**
			* @see ISegmentInserter::Insert
			* @reqid 001.0064
			*/
			void Insert( GridCell* cell, Error& error )
			{
				cell->InsertLeader( m_leader, m_label, error );
			}

		private:
			Label* m_label;
			Leader* m_leader;
		};


		/**
		 * Fixed grid spatial index. The index is a collection of equisized grid cells.
		 * Each cell maintains a dictionary of segments overlapping with it. It's very fast to build
		 * and fast on querying. The downside is that it does not consider the density of the map and
		 * the same cell density is used for very dense and scarce map regions. It is capable of indexing
		 * any upright-rectangular region.
		 * @reqid 001.0064
		 */
		class LABELINGENGINE_API FixedGridIndex : public ISpatialIndex
		{
		public:
			/**
			 * Possible error codes returned by the class.
			 * @reqid 001.0064
			 */
			enum ErrorCode
			{
				ErrorCode_AllocationError = 1,
				ErrorCode_InvalidExtent,
				ErrorCode_IndexOutOfBounds,
			};

			/**
			 * Parameterized constructor.
			 * @param minCellSize minimum size of the cell to be created
			 * @param llx lower left x coordinate of the indexed region
			 * @param lly lower left y coordinate of the indexed region
			 * @param width width of the indexed region
			 * @param height height of the indexed region
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			FixedGridIndex( float minCellSize, float llx, float lly, float width, float height, Error& errorInfo );

			/**
			 * Destructor.
			 * @reqid 001.0064
			 */
			virtual ~FixedGridIndex();

			/**
			* @see ISpatialIndex::Insert
			* @reqid 001.0064
			*/
			void Insert( Polyline& polyline, const Feature& feature, Error &errorInfo );

			/**
			* @see ISpatialIndex::Insert
			* @reqid 001.0064
			*/
			void Insert( Label* label, TextPart* textPart, Error& error );

			/**
			* @see ISpatialIndex::Insert
			* @reqid 001.0064
			*/
			void Insert( Label* label, Leader* leader, Error& error );

			/**
			* @see ISpatialIndex::Insert
			* @reqid 001.0064
			*/
			void Insert( Label* label, SymbolComponent* symbolComponent, float angle, Error& error );

			/**
			* @see ISpatialIndex::Insert
			* @reqid 001.0064
			*/
			void Insert( const Polygon& opaquePolygon, const Feature& feature, Error &errorInfo );

			/**
			* @see ISpatialIndex::GetPotentialOverlaps
			* @reqid 001.0064
			*/
			void GetPotentialOverlaps( const Rectangle& query, LinkedList<IndexDictionaryEntry::Collection>** candidates, Error& errorInfo ) const;


#if defined(_DEBUG) || defined(DISPLAY_DEBUGGER)
			float GetCellWidth() const
			{
				return m_cellWidth;
			}

			float GetCellHeight() const
			{
				return m_cellHeight;
			}
#endif

// Uncomment the following to allow for benchmarking and diagnostic code
//#define BENCHMARK
#ifdef BENCHMARK
			
			/**
			 * Dump the index content to a file for debugging
			 * @param path path of the dump file to be created. If file exists it will be overwritten.
			 * @return 
			 * @reqid 001.0064
			 */
			void Dump( String &path );
#endif

			virtual const TCHAR* GetIdentity()
			{
				return FixedGridIndex::ClassIdentity();
			}

			/**
			 * Type ID
			 * @reqid N/A.
			 */
			static const TCHAR* ClassIdentity()
			{
				return "MapText.Dtp.FixedGridIndex";
			}

            /**
             * Removes all references of a single feature from the index.
             * @param feature - The feature to be removed from the index.
             * @param errorInfo - Error information.
             */
            void RemoveFeatureFromIndex( Feature& feature, Error& errorInfo );

		protected:
            
            GridCell& GetCell( int x, int y ) const
            {
                assert( m_cells != NULL );
                assert( x >= 0 );
                assert( x < m_xCells );
                assert( y >= 0 );
                assert( y < m_yCells );
                
                return m_cells[ y*m_xCells + x ];
            }
            
			Point m_lowerLeft;
			float m_width;
			float m_height;
			int m_xCells;
			int m_yCells;
			float m_cellWidth;
			float m_cellHeight;
			GridCell* m_cells;

#ifdef S11N

			/**
			 * Default constructor needed by derived class
			 * @reqid N/A.
			 */
			FixedGridIndex(){};
#endif

			/**
			 * Insert the segment into the cell defined by the given coordinates using the inserter
			 * supplied
			 * @param inserter the inserter implementation
			 * @param xIndex x index of the cell to insert the segment to
			 * @param yIndex y index of the cell to insert the segment to
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			void InsertSegment( ISegmentInserter* inserter, int xIndex, int yIndex , Error& errorInfo );

			/**
			 * Inserts a single polyline segment to the index
			 * @param polyline the polyline that owns the segment
			 * @param segmentNumber number of the segment within the polyline
			 * @param feature feature to which the polyline belongs to
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			void InsertPolylineSegment( const Polyline& polyline, int segmentNumber, const Feature& feature, Error& errorInfo );

			/**
			 * Insert or remove the segment of given coordinates using the inserter supplied
			 * @param startX start x coordinate of the segment
			 * @param startY start y coordinate of the segment
			 * @param endX end x coordinate of the segment
			 * @param endY end y coordinate of the segment
			 * @param inserter the inserter for the segment
             * @param remove - if true the segment will be removed not inserted
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			void InsertOrRemoveSegment( float startX, float startY, float endX, float endY, 
				ISegmentInserter* inserter, bool remove, Error& errorInfo );

			/**
			* Append the polylines dictionary of a cell to the collection of dictionaries given. If an out-of-bounds 
			* x or y cell index is requested it is ignored, i.e. nothing is added to the collection.
			* @param xIndex x index of the cell which dictionary should be added
			* @param yIndex y index of the cell which dictionary should be added
			* @param candidates the collection to which the dictionary should be added
			* @param errorInfo error information
			* @return 0 on success, non-zero error code otherwise
			* @reqid 001.0064
			*/
			void AppendCellPolylineDictionary( int xIndex, int yIndex, LinkedList<IndexDictionaryEntry::Collection>* candidates, Error& errorInfo ) const;

			/**
			 * Insert a rectangular obstacle into the spatial index.
			 * A heuristic solution is used creating several segments parpendicular to the 
			 * rectantgle base and using them to find the proper map cells (approach
			 * taken from LPS).
			 * @param obstacle the obstacle rectangle
			 * @param length length of the rectangle (has to be a longer dimension)
			 * @param inserter proper segment inserter
			 * @param error error info.
			 * @reqid 001.0064
			 */
			void InsertRectangularObstacle( const Rectangle* obstacle, float length, ISegmentInserter* inserter, Error& error );

			/**
			 * Initialization.
			 * @param minCellSize minimum size of the cell to be created
			 * @param llx lower left x coordinate of the indexed region
			 * @param lly lower left y coordinate of the indexed region
			 * @param width width of the indexed region
			 * @param height height of the indexed region
			 * @param ignoreConfiguration - if set to true then pre-set values of cell dimensions 
			 *                              are used. Otherwise they are calculated using the Configuration
			 *                              constraints.
			 * @param errorInfo error information
			 * @reqid 001.0064
			 */
			void Initialize( float minCellSize, float llx, float lly, float width, float height, bool ignoreConfiguration, Error& errorInfo );
            
            virtual void RemoveSegment( ISegmentInserter* inserter, int xIndex, int yIndex , Error& errorInfo );
            
            virtual void RemoveFeatureFromIndex( Polyline& polyline, const Feature& feature, Error &errorInfo );
		};

	} // namespace Dtp
} // namespace MapText

#pragma warning( pop )

#endif // DTP_FIXEDGRIDINDEX_H
